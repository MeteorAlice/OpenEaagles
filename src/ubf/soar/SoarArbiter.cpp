/**
 * @file        SoarArbiter.cpp
 * @brief       Implementation of class SoarArbiter.
 * @details     
 *
 * @author      Marsil de Athayde Costa e Silva,
 * @author      Instituto Tecnologico de Aeronautica - ITA
 * @author      Laboratorio de Comando e Controle - ITA LAB C2
 * 
 * @date        13/06/2014
 * @version     1.0
 * @pre         
 * @bug         
 * @copyright   Copyright (c) 2014
 *
 */

#include "openeaagles/ubf/soar/SoarArbiter.h"

namespace oe {
namespace soar {

IMPLEMENT_SUBCLASS(SoarArbiter, "SoarArbiter")
EMPTY_COPYDATA(SoarArbiter)
EMPTY_SERIALIZER(SoarArbiter)

/** Slot table for this class type. */
BEGIN_SLOTTABLE(SoarArbiter)
   "soarFileName",                /**  1) soarFileName */
END_SLOTTABLE(SoarArbiter)

/** Mapping of slots to handles. */
BEGIN_SLOT_MAP(SoarArbiter)
   ON_SLOT(1, setSlotSoarFileName, base::String)
END_SLOT_MAP()


/**
 * @brief Class constructor.
 */
SoarArbiter::SoarArbiter()
{
    STANDARD_CONSTRUCTOR()
    soarFileName = new base::String();
}

 
/**
 * @brief deleteData()
 */
void SoarArbiter::deleteData()
{
    if ( soarFileName != 0 ) { soarFileName -> unref(); soarFileName = 0; }
    m_Kernel -> Shutdown();   
    delete m_Kernel;
}

/**
 * @brief Set slot SoarFileName.
 */
bool SoarArbiter::setSlotSoarFileName( base::String * const x )
{
    if ( soarFileName != 0 )
    {
       soarFileName -> unref();
       soarFileName = 0;
    }
    if ( x != 0)
    {
       soarFileName = x -> clone();
    }
    
    initSoar();

    return true;
}

 
/**
 * @brief getSlotByIndex()
 */
base::Object* SoarArbiter::getSlotByIndex(const int si)
{
   return BaseClass::getSlotByIndex(si);
}

 
/**
 * @brief Generates an actions by calling a SOAR script.
 */
base::ubf::Action* SoarArbiter::genAction( const base::ubf::State* const state, const double dt )
{
    static double l_timer = 1;
    l_timer += dt;
    // create list for action set
    base::List* actionSet = new base::List();

    // fill out list of recommended actions by behaviors
    if( l_timer >= 1.0 ) 
    {
        Commit( ( oe::behaviors::PlaneState*) state );
        Run();
        Retrieve();
        l_timer = 0;
    }

    // return action to perform generated by our base class
    return BaseClass::genAction( state, dt );
}

/**
 * @brief Generates a complex action from a set of actions. By default, it selects the action with the highest vote.
 */
base::ubf::Action * SoarArbiter::genComplexAction( base::List* const actionSet )
{
    oe::behaviors::PlaneAction * complexAction = new oe::behaviors::PlaneAction;

    unsigned int maxPitchVote = 0;
    unsigned int maxRollVote = 0;
    unsigned int maxHeadingVote = 0;
    unsigned int maxFireVote = 0;
    unsigned int maxThrottleVote = 0;
    unsigned int maxPitchTrimVote = 0;

    // process entire action set
    const base::List::Item* item = actionSet->getFirstItem();
    while ( item != 0 )
    {
        const oe::behaviors::PlaneAction * action = dynamic_cast<const oe::behaviors::PlaneAction*> ( item->getValue() );
        if ( action!=0 )
        {
            if( action->isHeadingChanged() && action->getVote() > maxHeadingVote )
            {
                complexAction->setHeading( action->getHeading() );
                maxHeadingVote = action->getVote();
            }
            if( action->isPitchChanged() && action->getVote() > maxPitchVote )
            {
                complexAction->setPitch( action->getPitch() );
                maxPitchVote = action->getVote();
            }
            if( action->isRollChanged() && action->getVote() > maxRollVote )
            {
                complexAction->setRoll( action->getRoll() );
                maxRollVote = action->getVote();
            }
            if( action->isFireMissileChanged() && action->getVote() > maxFireVote )
            {
                complexAction->setFireMissile( action->getFireMissile() );
                maxFireVote = action->getVote();
            }
            if( action->isThrottleChanged() && action->getVote() > maxThrottleVote )
            {
                complexAction->setThrottle( action->getThrottle() );
                maxThrottleVote = action->getVote();
            }
            if( action->isPitchTrimChanged() && action->getVote() > maxPitchTrimVote )
            {
                complexAction->setPitchTrim( action->getPitchTrim() );
                maxPitchTrimVote = action->getVote();
            }
        }
        else
        {
            std::cout << "Action NOT a PlaneAction\n";
        }
        // next action
        item = item->getNext();
    }
    
    trimChangeValidation(complexAction);
    return complexAction;
}

/**
 * @brief trimChangeValidation()
 */
void SoarArbiter::trimChangeValidation( base::ubf::Action * const complexAction )
{
    oe::behaviors::PlaneAction * action = (oe::behaviors::PlaneAction*)(complexAction);

    if ( action->isPitchChanged() && action->isPitchTrimChanged() )
    {
        //ignore pitch trim ONLY if the change goes against the action we want to
        //take with the control stick.
        if ( action->getPitch()>0 )
        {
            if ( action->getPitchTrim()<0 )
            {
                action->setPitchTrim(0);
            }
        }
        else
        {
            if ( action->getPitchTrim()>0 )
            {
                action->setPitchTrim(0);
            }
        }
    }
    return;
}

/**
 * @brief Initialize Soar agent.
 */
void SoarArbiter::initSoar()
{
    m_Kernel = Kernel::CreateKernelInNewThread();
    if( m_Kernel -> HadError() )
    {
        std::cout << m_Kernel -> GetLastErrorDescription() << std::endl;
    }
    
    m_smlAgent = m_Kernel -> CreateAgent( getFactoryName() );
    
    if ( m_Kernel -> HadError() )
    {
        std::cout << m_Kernel -> GetLastErrorDescription() << std::endl;
    }
    
    m_smlAgent -> LoadProductions( getSoarFileName() -> getCopyString() );
    
    if ( m_smlAgent -> HadError() )
    {
        std::cout << m_smlAgent -> GetLastErrorDescription() << std::endl;
    }
    
    m_soarState     = new SoarState( m_smlAgent );
    m_inputLink     = m_smlAgent -> GetInputLink();
    m_ID            = m_smlAgent -> CreateIdWME( m_inputLink, SoarState::getFactoryName() );

    m_soarState -> setRoll              ( m_smlAgent -> CreateFloatWME( m_ID, "roll-is",        0 ) );
    m_soarState -> setPitch             ( m_smlAgent -> CreateFloatWME( m_ID, "pitch-is",       0 ) );
    m_soarState -> setHeading           ( m_smlAgent -> CreateFloatWME( m_ID, "heading-is",     0 ) );
    m_soarState -> setRollRate          ( m_smlAgent -> CreateFloatWME( m_ID, "roll-rate-is",   0 ) );
    m_soarState -> setPitchRate         ( m_smlAgent -> CreateFloatWME( m_ID, "pitch-rate-is",  0 ) );
    m_soarState -> setYawRate           ( m_smlAgent -> CreateFloatWME( m_ID, "yaw-rate-is",    0 ) );
    m_soarState -> setAltitude          ( m_smlAgent -> CreateFloatWME( m_ID, "altitude-is",    0 ) );
    m_soarState -> setThrottle          ( m_smlAgent -> CreateFloatWME( m_ID, "throttle-is",    0 ) );
    m_soarState -> setSpeed             ( m_smlAgent -> CreateFloatWME( m_ID, "speed-is",       0 ) );
    m_soarState -> setPitchTrim         ( m_smlAgent -> CreateFloatWME( m_ID, "pitch-trim-is",  0 ) );

    m_soarState -> setNumTracks         ( m_smlAgent -> CreateIntWME( m_ID, "num-tracks-is",        0 ) );
    m_soarState -> setTargetTrack       ( m_smlAgent -> CreateIntWME( m_ID, "target-track-is",      0 ) );
    m_soarState -> setNumEngines        ( m_smlAgent -> CreateIntWME( m_ID, "num-engines-is",       0 ) );
    
    m_soarState -> setAlive             ( m_smlAgent -> CreateIntWME( m_ID, "is-alive",             0 ) );
    m_soarState -> setTracking          ( m_smlAgent -> CreateIntWME( m_ID, "is-tracking",          0 ) );
    m_soarState -> setMissileFired      ( m_smlAgent -> CreateIntWME( m_ID, "is-missile-fired",     0 ) );
    m_soarState -> setIncomingMissile   ( m_smlAgent -> CreateIntWME( m_ID, "is-incoming-missile",  0 ) );
    
    m_soarState -> setPitchToTracked    ( m_smlAgent -> CreateFloatWME( m_ID, "pitch-to-tracked-is",    0 ) );
    m_soarState -> setHeadingToTracked  ( m_smlAgent -> CreateFloatWME( m_ID, "heading-to-tracked-is",  0 ) );
    m_soarState -> setDistanceToTracked ( m_smlAgent -> CreateFloatWME( m_ID, "distance-to-tracked-is", 0 ) );
}

/**
 * @brief Commit the states of the aircraft.
 */
void SoarArbiter::Commit( const base::ubf::State * const state )
{
    const oe::behaviors::PlaneState * l_state = dynamic_cast<const oe::behaviors::PlaneState*> ( state );
    m_smlAgent -> Update( m_soarState -> getRoll(),         l_state -> getRoll() );
    m_smlAgent -> Update( m_soarState -> getPitch(),        l_state -> getPitch() );
    m_smlAgent -> Update( m_soarState -> getHeading(),      l_state -> getHeading() );
    m_smlAgent -> Update( m_soarState -> getRollRate(),     l_state -> getRollRate() );
    m_smlAgent -> Update( m_soarState -> getPitchRate(),    l_state -> getPitchRate() );
    m_smlAgent -> Update( m_soarState -> getYawRate(),      l_state -> getYawRate() );
    m_smlAgent -> Update( m_soarState -> getAltitude(),     l_state -> getAltitude() );
    m_smlAgent -> Update( m_soarState -> getThrottle(),     l_state -> getThrottle() );
    m_smlAgent -> Update( m_soarState -> getSpeed(),        l_state -> getSpeed() );
    m_smlAgent -> Update( m_soarState -> getPitchTrim(),    l_state -> getPitchTrim() );

    m_smlAgent -> Update( m_soarState -> getNumTracks(),    l_state -> getNumTracks() );
    m_smlAgent -> Update( m_soarState -> getTargetTrack(),  l_state -> getTargetTrack() );
    m_smlAgent -> Update( m_soarState -> getNumEngines(),   l_state -> getNumEngines() );
    
    m_smlAgent -> Update( m_soarState -> getAlive(),            ( l_state -> isAlive()            == true ) ? ( 1 ) : ( 0 ) );
    m_smlAgent -> Update( m_soarState -> getTracking(),         ( l_state -> isTracking()         == true ) ? ( 1 ) : ( 0 ) );
    m_smlAgent -> Update( m_soarState -> getMissileFired(),     ( l_state -> isMissileFired()     == true ) ? ( 1 ) : ( 0 ) );
    m_smlAgent -> Update( m_soarState -> getIncomingMissile(),  ( l_state -> isIncomingMissile()  == true ) ? ( 1 ) : ( 0 ) );
    
    if( l_state -> isTracking() && l_state -> getTargetTrack() < l_state -> getNumTracks() )
    {
        m_smlAgent -> Update( m_soarState -> getPitchToTracked(),       l_state -> getPitchToTracked( l_state -> getTargetTrack() ) );
        m_smlAgent -> Update( m_soarState -> getHeadingToTracked(),     l_state -> getHeadingToTracked( l_state -> getTargetTrack() ) );
        m_smlAgent -> Update( m_soarState -> getDistanceToTracked(),    l_state -> getDistanceToTracked( l_state -> getTargetTrack() ) );
    }
    else
    {
        m_smlAgent -> Update( m_soarState -> getPitchToTracked(),       0 );
        m_smlAgent -> Update( m_soarState -> getHeadingToTracked(),     0 );
        m_smlAgent -> Update( m_soarState -> getDistanceToTracked(),    0 );
    }
    // Send the changes to working memory to Soar
    // With 8.6.2 this call is optional as changes are sent automatically.
    m_smlAgent -> Commit();
}

/**
 * @brief Run Soar.
 */
void SoarArbiter::Run()
{
    m_smlAgent -> RunSelfTilOutput();
}

/**
 * @brief Retrieves information from Soar environment.
 */
void SoarArbiter::Retrieve()
{
    sml::Identifier * l_OutputLink = m_smlAgent -> GetOutputLink();
 
    int numberCommands = m_smlAgent -> GetNumberCommands();
    for (int i = 0 ; i < numberCommands ; i++)
    {
        sml::Identifier * pCommand = m_smlAgent -> GetCommand(i);
        
        const std::string l_cmdName = pCommand->GetCommandName();
        //const char * c_name_s   = pCommand->GetValueAsString();
        
        if( l_cmdName == "behaviors" )
        {
            std::string l_behaviorName = pCommand->GetParameterValue( "name" );
            if( l_behaviorName != "init" )
            {
                base::Object * l_bhv = 0;
                if( l_bhv == 0 )
                {
                    l_bhv = behaviors::factory( l_behaviorName.c_str() );
                }
                if( l_bhv == 0 )
                {
                    l_bhv = lua::factory( l_behaviorName.c_str() );
                }

                int j = 1;
                int bla = pCommand -> GetNumberChildren();
                WMElement * l_WME = pCommand -> GetChild( j );
                while( l_WME != 0 )
                {
                    base::Object * l_param;
                    
                    std::string l_valueType = l_WME -> GetValueType();

                    if( l_valueType == "string" )
                    {
                        l_param = new base::String( l_WME -> ConvertToStringElement() -> GetValue() );
                    }
                    else if( l_valueType == "int" )
                    {
                        l_param = new base::Integer( l_WME -> ConvertToIntElement() -> GetValue() );
                    }
                    else if( l_valueType == "double" )
                    {
                        l_param = new base::Number( l_WME -> ConvertToFloatElement() -> GetValue() );
                    }
                    else if( l_valueType == "id" )
                    {// this is somewhat LuaBehavior specific
                        int k = 0;
                        WMElement * l_WMEoptPairStream = l_WME -> ConvertToIdentifier() -> GetChild( k );
                        base::Pair * l_pair;
                        l_param = new base::PairStream();

                        while( l_WMEoptPairStream != 0 )
                        {
                            base::Object * l_pairobj;
                            
                            l_valueType = l_WMEoptPairStream -> GetValueType();

                            if( l_valueType == "string" )
                            {
                                l_pairobj = new base::String( l_WMEoptPairStream -> ConvertToStringElement() -> GetValue() );
                            }
                            else if( l_valueType == "int" )
                            {
                                l_pairobj = new base::Integer( l_WMEoptPairStream -> ConvertToIntElement() -> GetValue() );
                            }
                            else if( l_valueType == "double" )
                            {
                                l_pairobj = new base::Number( l_WMEoptPairStream -> ConvertToFloatElement() -> GetValue() );
                            }

                            l_pair = new base::Pair( l_WMEoptPairStream -> GetAttribute(), l_pairobj );
                            ( (base::PairStream*) l_param ) -> addTail( l_pair );

                            l_WMEoptPairStream = l_WME -> ConvertToIdentifier() -> GetChild( ++k );
                        }
                    }
                    l_bhv -> setSlotByName( l_WME -> GetAttribute(), l_param );
                    
                    l_WME = pCommand -> GetChild( ++j );
                }

                if( l_bhv != 0 )
                {
                    addBehavior( ( base::ubf::Behavior*) l_bhv );
                }
            }
        }
    }
}

}
}
